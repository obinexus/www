<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIRAM - The Memory That Actually Gets You | OBINexus</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @font-face {
            font-family: 'Circuit';
            src: url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        }

        body {
            font-family: 'Orbitron', 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #ffffff;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        /* Hero Section with 3D Canvas */
        .hero {
            position: relative;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #diram-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            max-width: 800px;
            margin: 0 auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .tagline {
            font-size: 1.5rem;
            color: #00ff88;
            margin-bottom: 2rem;
            font-weight: 300;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-panel h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .control-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-color: #00ff88;
        }

        /* Stats Display */
        .stats-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 250px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .coherence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .coherence-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ff88);
            width: 95.4%;
            transition: width 0.3s ease;
        }

        /* Feature Sections */
        .features {
            padding: 4rem 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .feature-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 2rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .feature-card:hover {
            transform: translateY(-10px);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .feature-icon {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .feature-title {
            font-size: 1.3rem;
            color: #00ff88;
            margin-bottom: 1rem;
        }

        .feature-desc {
            color: #ccc;
            line-height: 1.6;
        }

        /* Bioergonomics Section */
        .bio-section {
            padding: 4rem 2rem;
            background: rgba(0, 20, 40, 0.3);
        }

        .bio-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .bio-title {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 2rem;
        }

        .principle-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .principle-item {
            background: rgba(0, 255, 136, 0.1);
            padding: 1.5rem;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        /* CTA Section */
        .cta-section {
            padding: 4rem 2rem;
            text-align: center;
        }

        .cta-button {
            display: inline-block;
            padding: 1rem 3rem;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            border-radius: 50px;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .cta-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.5);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .tagline {
                font-size: 1rem;
            }
            .control-panel {
                top: auto;
                bottom: 100px;
                right: 10px;
                left: 10px;
            }
            .stats-display {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Hero Section with 3D Visualization -->
    <section class="hero">
        <canvas id="diram-canvas"></canvas>
        <div class="hero-content">
            <h1>DIRAM</h1>
            <p class="tagline">The Memory That Actually Gets You</p>
            <p style="margin-bottom: 2rem;">Revolutionary active memory architecture solving the coherence problem in classical-quantum hybrid systems through Hamiltonian-Eulerian constraints.</p>
            <a href="#features" class="cta-button">Explore Features</a>
        </div>
    </section>

    <!-- Control Panel -->
    <div class="control-panel">
        <h3>üéÆ Interactive Controls</h3>
        <button class="control-btn" id="rotate-btn">Auto Rotate</button>
        <button class="control-btn" id="filter-mode-btn">Filter Mode</button>
        <button class="control-btn" id="flash-mode-btn">Flash Mode</button>
        <button class="control-btn" id="allocate-btn">Simulate Allocation</button>
        <button class="control-btn" id="show-gates-btn">Show Logic Gates</button>
    </div>

    <!-- Stats Display -->
    <div class="stats-display">
        <h3 style="color: #00ff88; margin-bottom: 15px;">üìä Live Metrics</h3>
        <div class="stat-item">
            <span class="stat-label">Mode:</span>
            <span class="stat-value" id="mode-display">FILTER</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Allocations:</span>
            <span class="stat-value" id="alloc-count">0 / 3</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Coherence:</span>
            <span class="stat-value">95.4%</span>
        </div>
        <div class="coherence-bar">
            <div class="coherence-fill"></div>
        </div>
        <div class="stat-item" style="margin-top: 10px;">
            <span class="stat-label">Latency:</span>
            <span class="stat-value">0.3ms</span>
        </div>
    </div>

    <!-- Features Section -->
    <section id="features" class="features">
        <h2 style="text-align: center; font-size: 2.5rem; margin-bottom: 1rem; color: #00ff88;">Core Features</h2>
        <p style="text-align: center; color: #888; margin-bottom: 3rem;">Built different. Built for the future.</p>
        
        <div class="feature-grid">
            <div class="feature-card">
                <div class="feature-icon">üß†</div>
                <h3 class="feature-title">Predictive Memory</h3>
                <p class="feature-desc">DIRAM predicts what data you'll need next with 95.4% accuracy, eliminating memory bottlenecks before they happen.</p>
            </div>
            
            <div class="feature-card">
                <div class="feature-icon">‚ö°</div>
                <h3 class="feature-title">Filter-Flash Modes</h3>
                <p class="feature-desc">Dynamically switches between deep analytical Filter mode and lightning-fast Flash mode based on your needs.</p>
            </div>
            
            <div class="feature-card">
                <div class="feature-icon">üîê</div>
                <h3 class="feature-title">Cryptographic Receipts</h3>
                <p class="feature-desc">Every allocation generates SHA-256 receipts, ensuring zero-trust verification and complete data integrity.</p>
            </div>
            
            <div class="feature-card">
                <div class="feature-icon">üîß</div>
                <h3 class="feature-title">Self-Healing</h3>
                <p class="feature-desc">Automatically detects and repairs corrupted memory sectors, maintaining data integrity without intervention.</p>
            </div>
            
            <div class="feature-card">
                <div class="feature-icon">üéØ</div>
                <h3 class="feature-title">Three-Gate Logic</h3>
                <p class="feature-desc">Minimal hardware design using only NOT, XOR, and AND gates achieves maximum efficiency with O(1) operations.</p>
            </div>
            
            <div class="feature-card">
                <div class="feature-icon">üåç</div>
                <h3 class="feature-title">Quantum-Ready</h3>
                <p class="feature-desc">Bridges classical and quantum computing realms through unified coherence policy pool architecture.</p>
            </div>
        </div>
    </section>

    <!-- Bioergonomics Section -->
    <section class="bio-section">
        <div class="bio-content">
            <h2 class="bio-title">Bioergonomics Integration</h2>
            <p style="color: #ccc; margin-bottom: 2rem; max-width: 800px; margin: 0 auto 2rem;">DIRAM powers the OBINexus Bioergonomics vision - creating sustainable, collapse-resistant infrastructure that puts humans first.</p>
            
            <div class="principle-list">
                <div class="principle-item">
                    <h4 style="color: #00ff88; margin-bottom: 0.5rem;">üè† Smart Housing</h4>
                    <p>Powers transformable spaces that adapt to your needs in real-time.</p>
                </div>
                <div class="principle-item">
                    <h4 style="color: #00ff88; margin-bottom: 0.5rem;">üõ°Ô∏è Collapse-Resistant</h4>
                    <p>Maintains critical functions even during system failures.</p>
                </div>
                <div class="principle-item">
                    <h4 style="color: #00ff88; margin-bottom: 0.5rem;">üë§ Human-Centered</h4>
                    <p>Computing from the heart - technology that actually cares.</p>
                </div>
                <div class="principle-item">
                    <h4 style="color: #00ff88; margin-bottom: 0.5rem;">üåø Sustainable</h4>
                    <p>95% more efficient than traditional memory architectures.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- CTA Section -->
    <section class="cta-section">
        <h2 style="font-size: 2rem; margin-bottom: 1rem;">Ready to Experience the Future?</h2>
        <p style="color: #888; margin-bottom: 2rem;">When systems fail, build your own. DIRAM is that build.</p>
        <a href="https://github.com/obinexus/diram" class="cta-button">Get Started with DIRAM</a>
    </section>

    <!-- Three.js Implementation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // DIRAM 3D Visualization
        class DIRAMVisualizer {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('diram-canvas'),
                    alpha: true,
                    antialias: true 
                });
                
                this.memoryBlocks = [];
                this.particles = [];
                this.gates = [];
                this.mode = 'filter';
                this.autoRotate = true;
                this.allocations = 0;
                this.showGates = true;
                
                this.init();
                this.createDIRAM();
                this.createParticles();
                this.createGates();
                this.animate();
                this.setupControls();
            }
            
            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                
                this.camera.position.set(12, 8, 12);
                this.camera.lookAt(0, 0, 0);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                this.scene.add(directionalLight);
                
                const pointLight = new THREE.PointLight(0x00ff88, 1, 20);
                pointLight.position.set(0, 5, 0);
                this.scene.add(pointLight);
                
                // Handle resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            createDIRAM() {
                // Create main CPU-like structure
                const mainGeometry = new THREE.BoxGeometry(8, 1, 8);
                const mainMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2a2a3e,
                    emissive: 0x2a2a3e,
                    emissiveIntensity: 0.1,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const mainChip = new THREE.Mesh(mainGeometry, mainMaterial);
                this.scene.add(mainChip);
                
                // Create memory grid (4x4x4 tensor visualization)
                const gridSize = 4;
                const spacing = 1.8;
                
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        for (let z = 0; z < gridSize; z++) {
                            const blockGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                            const hue = ((x + y + z) / 12) * 360;
                            const blockMaterial = new THREE.MeshPhongMaterial({
                                color: new THREE.Color(`hsl(${hue}, 70%, 50%)`),
                                emissive: new THREE.Color(`hsl(${hue}, 70%, 30%)`),
                                emissiveIntensity: 0.3,
                                transparent: true,
                                opacity: 0.8
                            });
                            
                            const block = new THREE.Mesh(blockGeometry, blockMaterial);
                            block.position.set(
                                (x - 1.5) * spacing,
                                y * 0.6 + 1,
                                (z - 1.5) * spacing
                            );
                            
                            block.userData = {
                                x, y, z,
                                active: false,
                                originalColor: blockMaterial.color.clone()
                            };
                            
                            this.memoryBlocks.push(block);
                            this.scene.add(block);
                        }
                    }
                }
                
                // Create circuit traces
                const traceGeometry = new THREE.PlaneGeometry(0.05, 8);
                const traceMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                
                for (let i = -3; i <= 3; i++) {
                    const trace1 = new THREE.Mesh(traceGeometry, traceMaterial);
                    trace1.position.set(i, 0.51, 0);
                    trace1.rotation.x = -Math.PI / 2;
                    this.scene.add(trace1);
                    
                    const trace2 = new THREE.Mesh(traceGeometry, traceMaterial);
                    trace2.position.set(0, 0.51, i);
                    trace2.rotation.x = -Math.PI / 2;
                    trace2.rotation.z = Math.PI / 2;
                    this.scene.add(trace2);
                }
                
                // Add pins
                const pinGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
                const pinMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700 });
                
                for (let i = -3; i <= 3; i += 0.5) {
                    const pin1 = new THREE.Mesh(pinGeometry, pinMaterial);
                    pin1.position.set(i, -0.5, 3.8);
                    this.scene.add(pin1);
                    
                    const pin2 = new THREE.Mesh(pinGeometry, pinMaterial);
                    pin2.position.set(i, -0.5, -3.8);
                    this.scene.add(pin2);
                }
            }
            
            createParticles() {
                const particleCount = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 15;
                    positions[i * 3 + 1] = Math.random() * 10;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 15;
                    
                    const color = this.mode === 'filter' 
                        ? new THREE.Color(0x4444ff)
                        : new THREE.Color(0xff8800);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
            }
            
            createGates() {
                const gateData = [
                    { name: 'NOT', color: 0xff0000, position: new THREE.Vector3(-6, 3, 0), symbol: '!' },
                    { name: 'XOR', color: 0x00ff00, position: new THREE.Vector3(0, 3, -6), symbol: '‚äï' },
                    { name: 'AND', color: 0x0000ff, position: new THREE.Vector3(6, 3, 0), symbol: '&' }
                ];
                
                gateData.forEach(gate => {
                    // Gate body
                    const geometry = new THREE.ConeGeometry(0.8, 1.5, 4);
                    const material = new THREE.MeshPhongMaterial({
                        color: gate.color,
                        emissive: gate.color,
                        emissiveIntensity: 0.3,
                        metalness: 0.5,
                        roughness: 0.3
                    });
                    
                    const gateMesh = new THREE.Mesh(geometry, material);
                    gateMesh.position.copy(gate.position);
                    gateMesh.userData = gate;
                    gateMesh.visible = this.showGates;
                    
                    this.gates.push(gateMesh);
                    this.scene.add(gateMesh);
                    
                    // Connection line
                    const points = [gate.position, new THREE.Vector3(0, 1, 0)];
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: gate.color,
                        transparent: true,
                        opacity: 0.3
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    line.visible = this.showGates;
                    this.gates.push(line);
                    this.scene.add(line);
                });
            }
            
            animateMemoryBlocks() {
                this.memoryBlocks.forEach((block, index) => {
                    if (block.userData.active) {
                        const scale = 1 + Math.sin(Date.now() * 0.003 + index) * 0.1;
                        block.scale.set(scale, scale, scale);
                        block.rotation.y += 0.02;
                    } else {
                        block.scale.set(1, 1, 1);
                        block.rotation.y = 0;
                    }
                });
            }
            
            animateParticles() {
                if (this.particleSystem) {
                    const positions = this.particleSystem.geometry.attributes.position.array;
                    const time = Date.now() * 0.001;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += Math.sin(time + i) * 0.01;
                        positions[i + 1] += Math.cos(time + i * 0.5) * 0.02;
                        positions[i + 2] += Math.sin(time + i * 0.3) * 0.01;
                        
                        // Wrap around
                        if (positions[i + 1] > 10) positions[i + 1] = 0;
                        if (Math.abs(positions[i]) > 7.5) positions[i] *= -0.9;
                        if (Math.abs(positions[i + 2]) > 7.5) positions[i + 2] *= -0.9;
                    }
                    
                    this.particleSystem.geometry.attributes.position.needsUpdate = true;
                    this.particleSystem.rotation.y += 0.001;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.autoRotate) {
                    this.scene.rotation.y += 0.003;
                }
                
                this.animateMemoryBlocks();
                this.animateParticles();
                
                this.gates.forEach(gate => {
                    if (gate.userData && gate.userData.name) {
                        gate.rotation.y += 0.02;
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
            }
            
            setupControls() {
                // Auto Rotate
                document.getElementById('rotate-btn').addEventListener('click', (e) => {
                    this.autoRotate = !this.autoRotate;
                    e.target.classList.toggle('active');
                });
                
                // Filter Mode
                document.getElementById('filter-mode-btn').addEventListener('click', (e) => {
                    this.setMode('filter');
                    e.target.classList.add('active');
                    document.getElementById('flash-mode-btn').classList.remove('active');
                });
                
                // Flash Mode
                document.getElementById('flash-mode-btn').addEventListener('click', (e) => {
                    this.setMode('flash');
                    e.target.classList.add('active');
                    document.getElementById('filter-mode-btn').classList.remove('active');
                });
                
                // Allocate Memory
                document.getElementById('allocate-btn').addEventListener('click', () => {
                    this.simulateAllocation();
                });
                
                // Show/Hide Gates
                document.getElementById('show-gates-btn').addEventListener('click', (e) => {
                    this.showGates = !this.showGates;
                    this.gates.forEach(gate => gate.visible = this.showGates);
                    e.target.classList.toggle('active');
                });
                
                // Set initial states
                document.getElementById('filter-mode-btn').classList.add('active');
                document.getElementById('show-gates-btn').classList.add('active');
                document.getElementById('rotate-btn').classList.add('active');
            }
            
            setMode(mode) {
                this.mode = mode;
                document.getElementById('mode-display').textContent = mode.toUpperCase();
                
                // Update particle colors
                if (this.particleSystem) {
                    const colors = this.particleSystem.geometry.attributes.color.array;
                    const color = mode === 'filter' 
                        ? new THREE.Color(0x4444ff)
                        : new THREE.Color(0xff8800);
                    
                    for (let i = 0; i < colors.length; i += 3) {
                        colors[i] = color.r;
                        colors[i + 1] = color.g;
                        colors[i + 2] = color.b;
                    }
                    
                    this.particleSystem.geometry.attributes.color.needsUpdate = true;
                }
            }
            
            simulateAllocation() {
                if (this.allocations >= 3) {
                    this.allocations = 0;
                    this.memoryBlocks.forEach(block => {
                        block.userData.active = false;
                        block.material.emissiveIntensity = 0.3;
                    });
                }
                
                const randomBlocks = [];
                for (let i = 0; i < 5; i++) {
                    const index = Math.floor(Math.random() * this.memoryBlocks.length);
                    randomBlocks.push(this.memoryBlocks[index]);
                }
                
                randomBlocks.forEach(block => {
                    block.userData.active = true;
                    block.material.emissiveIntensity = 0.8;
                    
                    // Flash effect
                    setTimeout(() => {
                        block.material.emissiveIntensity = 0.5;
                    }, 500);
                });
                
                this.allocations++;
                document.getElementById('alloc-count').textContent = `${this.allocations} / 3`;
            }
        }
        
        // Initialize visualizer when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new DIRAMVisualizer();
        });
        
        // Smooth scroll
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });
    </script>
</body>
</html>